{"mappings":"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","sources":["<anon>","node_modules/.pnpm/node-fetch@3.3.1/node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar parcelRequire = $parcel$global[\"parcelRequire810d\"];\nparcelRequire.register(\"kCYt6\", function(module, exports) {\n\n$parcel$export(module.exports, \"toFormData\", () => $f0464300f9a0111b$export$10ae0d317ea97f8b);\n\nvar $wabHV = parcelRequire(\"wabHV\");\n\nvar $33Q0z = parcelRequire(\"33Q0z\");\nlet $f0464300f9a0111b$var$s = 0;\nconst $f0464300f9a0111b$var$S = {\n    START_BOUNDARY: $f0464300f9a0111b$var$s++,\n    HEADER_FIELD_START: $f0464300f9a0111b$var$s++,\n    HEADER_FIELD: $f0464300f9a0111b$var$s++,\n    HEADER_VALUE_START: $f0464300f9a0111b$var$s++,\n    HEADER_VALUE: $f0464300f9a0111b$var$s++,\n    HEADER_VALUE_ALMOST_DONE: $f0464300f9a0111b$var$s++,\n    HEADERS_ALMOST_DONE: $f0464300f9a0111b$var$s++,\n    PART_DATA_START: $f0464300f9a0111b$var$s++,\n    PART_DATA: $f0464300f9a0111b$var$s++,\n    END: $f0464300f9a0111b$var$s++\n};\nlet $f0464300f9a0111b$var$f = 1;\nconst $f0464300f9a0111b$var$F = {\n    PART_BOUNDARY: $f0464300f9a0111b$var$f,\n    LAST_BOUNDARY: $f0464300f9a0111b$var$f *= 2\n};\nconst $f0464300f9a0111b$var$LF = 10;\nconst $f0464300f9a0111b$var$CR = 13;\nconst $f0464300f9a0111b$var$SPACE = 32;\nconst $f0464300f9a0111b$var$HYPHEN = 45;\nconst $f0464300f9a0111b$var$COLON = 58;\nconst $f0464300f9a0111b$var$A = 97;\nconst $f0464300f9a0111b$var$Z = 122;\nconst $f0464300f9a0111b$var$lower = (c)=>c | 0x20;\nconst $f0464300f9a0111b$var$noop = ()=>{};\nclass $f0464300f9a0111b$var$MultipartParser {\n    /**\n\t * @param {string} boundary\n\t */ constructor(boundary){\n        this.index = 0;\n        this.flags = 0;\n        this.onHeaderEnd = $f0464300f9a0111b$var$noop;\n        this.onHeaderField = $f0464300f9a0111b$var$noop;\n        this.onHeadersEnd = $f0464300f9a0111b$var$noop;\n        this.onHeaderValue = $f0464300f9a0111b$var$noop;\n        this.onPartBegin = $f0464300f9a0111b$var$noop;\n        this.onPartData = $f0464300f9a0111b$var$noop;\n        this.onPartEnd = $f0464300f9a0111b$var$noop;\n        this.boundaryChars = {};\n        boundary = \"\\r\\n--\" + boundary;\n        const ui8a = new Uint8Array(boundary.length);\n        for(let i = 0; i < boundary.length; i++){\n            ui8a[i] = boundary.charCodeAt(i);\n            this.boundaryChars[ui8a[i]] = true;\n        }\n        this.boundary = ui8a;\n        this.lookbehind = new Uint8Array(this.boundary.length + 8);\n        this.state = $f0464300f9a0111b$var$S.START_BOUNDARY;\n    }\n    /**\n\t * @param {Uint8Array} data\n\t */ write(data) {\n        let i = 0;\n        const length_ = data.length;\n        let previousIndex = this.index;\n        let { lookbehind: lookbehind , boundary: boundary , boundaryChars: boundaryChars , index: index , state: state , flags: flags  } = this;\n        const boundaryLength = this.boundary.length;\n        const boundaryEnd = boundaryLength - 1;\n        const bufferLength = data.length;\n        let c;\n        let cl;\n        const mark = (name)=>{\n            this[name + \"Mark\"] = i;\n        };\n        const clear = (name)=>{\n            delete this[name + \"Mark\"];\n        };\n        const callback = (callbackSymbol, start, end, ui8a)=>{\n            if (start === undefined || start !== end) this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n        };\n        const dataCallback = (name, clear)=>{\n            const markSymbol = name + \"Mark\";\n            if (!(markSymbol in this)) return;\n            if (clear) {\n                callback(name, this[markSymbol], i, data);\n                delete this[markSymbol];\n            } else {\n                callback(name, this[markSymbol], data.length, data);\n                this[markSymbol] = 0;\n            }\n        };\n        for(i = 0; i < length_; i++){\n            c = data[i];\n            switch(state){\n                case $f0464300f9a0111b$var$S.START_BOUNDARY:\n                    if (index === boundary.length - 2) {\n                        if (c === $f0464300f9a0111b$var$HYPHEN) flags |= $f0464300f9a0111b$var$F.LAST_BOUNDARY;\n                        else if (c !== $f0464300f9a0111b$var$CR) return;\n                        index++;\n                        break;\n                    } else if (index - 1 === boundary.length - 2) {\n                        if (flags & $f0464300f9a0111b$var$F.LAST_BOUNDARY && c === $f0464300f9a0111b$var$HYPHEN) {\n                            state = $f0464300f9a0111b$var$S.END;\n                            flags = 0;\n                        } else if (!(flags & $f0464300f9a0111b$var$F.LAST_BOUNDARY) && c === $f0464300f9a0111b$var$LF) {\n                            index = 0;\n                            callback(\"onPartBegin\");\n                            state = $f0464300f9a0111b$var$S.HEADER_FIELD_START;\n                        } else return;\n                        break;\n                    }\n                    if (c !== boundary[index + 2]) index = -2;\n                    if (c === boundary[index + 2]) index++;\n                    break;\n                case $f0464300f9a0111b$var$S.HEADER_FIELD_START:\n                    state = $f0464300f9a0111b$var$S.HEADER_FIELD;\n                    mark(\"onHeaderField\");\n                    index = 0;\n                // falls through\n                case $f0464300f9a0111b$var$S.HEADER_FIELD:\n                    if (c === $f0464300f9a0111b$var$CR) {\n                        clear(\"onHeaderField\");\n                        state = $f0464300f9a0111b$var$S.HEADERS_ALMOST_DONE;\n                        break;\n                    }\n                    index++;\n                    if (c === $f0464300f9a0111b$var$HYPHEN) break;\n                    if (c === $f0464300f9a0111b$var$COLON) {\n                        if (index === 1) // empty header field\n                        return;\n                        dataCallback(\"onHeaderField\", true);\n                        state = $f0464300f9a0111b$var$S.HEADER_VALUE_START;\n                        break;\n                    }\n                    cl = $f0464300f9a0111b$var$lower(c);\n                    if (cl < $f0464300f9a0111b$var$A || cl > $f0464300f9a0111b$var$Z) return;\n                    break;\n                case $f0464300f9a0111b$var$S.HEADER_VALUE_START:\n                    if (c === $f0464300f9a0111b$var$SPACE) break;\n                    mark(\"onHeaderValue\");\n                    state = $f0464300f9a0111b$var$S.HEADER_VALUE;\n                // falls through\n                case $f0464300f9a0111b$var$S.HEADER_VALUE:\n                    if (c === $f0464300f9a0111b$var$CR) {\n                        dataCallback(\"onHeaderValue\", true);\n                        callback(\"onHeaderEnd\");\n                        state = $f0464300f9a0111b$var$S.HEADER_VALUE_ALMOST_DONE;\n                    }\n                    break;\n                case $f0464300f9a0111b$var$S.HEADER_VALUE_ALMOST_DONE:\n                    if (c !== $f0464300f9a0111b$var$LF) return;\n                    state = $f0464300f9a0111b$var$S.HEADER_FIELD_START;\n                    break;\n                case $f0464300f9a0111b$var$S.HEADERS_ALMOST_DONE:\n                    if (c !== $f0464300f9a0111b$var$LF) return;\n                    callback(\"onHeadersEnd\");\n                    state = $f0464300f9a0111b$var$S.PART_DATA_START;\n                    break;\n                case $f0464300f9a0111b$var$S.PART_DATA_START:\n                    state = $f0464300f9a0111b$var$S.PART_DATA;\n                    mark(\"onPartData\");\n                // falls through\n                case $f0464300f9a0111b$var$S.PART_DATA:\n                    previousIndex = index;\n                    if (index === 0) {\n                        // boyer-moore derrived algorithm to safely skip non-boundary data\n                        i += boundaryEnd;\n                        while(i < bufferLength && !(data[i] in boundaryChars))i += boundaryLength;\n                        i -= boundaryEnd;\n                        c = data[i];\n                    }\n                    if (index < boundary.length) {\n                        if (boundary[index] === c) {\n                            if (index === 0) dataCallback(\"onPartData\", true);\n                            index++;\n                        } else index = 0;\n                    } else if (index === boundary.length) {\n                        index++;\n                        if (c === $f0464300f9a0111b$var$CR) // CR = part boundary\n                        flags |= $f0464300f9a0111b$var$F.PART_BOUNDARY;\n                        else if (c === $f0464300f9a0111b$var$HYPHEN) // HYPHEN = end boundary\n                        flags |= $f0464300f9a0111b$var$F.LAST_BOUNDARY;\n                        else index = 0;\n                    } else if (index - 1 === boundary.length) {\n                        if (flags & $f0464300f9a0111b$var$F.PART_BOUNDARY) {\n                            index = 0;\n                            if (c === $f0464300f9a0111b$var$LF) {\n                                // unset the PART_BOUNDARY flag\n                                flags &= ~$f0464300f9a0111b$var$F.PART_BOUNDARY;\n                                callback(\"onPartEnd\");\n                                callback(\"onPartBegin\");\n                                state = $f0464300f9a0111b$var$S.HEADER_FIELD_START;\n                                break;\n                            }\n                        } else if (flags & $f0464300f9a0111b$var$F.LAST_BOUNDARY) {\n                            if (c === $f0464300f9a0111b$var$HYPHEN) {\n                                callback(\"onPartEnd\");\n                                state = $f0464300f9a0111b$var$S.END;\n                                flags = 0;\n                            } else index = 0;\n                        } else index = 0;\n                    }\n                    if (index > 0) // when matching a possible boundary, keep a lookbehind reference\n                    // in case it turns out to be a false lead\n                    lookbehind[index - 1] = c;\n                    else if (previousIndex > 0) {\n                        // if our boundary turned out to be rubbish, the captured lookbehind\n                        // belongs to partData\n                        const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n                        callback(\"onPartData\", 0, previousIndex, _lookbehind);\n                        previousIndex = 0;\n                        mark(\"onPartData\");\n                        // reconsider the current character even so it interrupted the sequence\n                        // it could be the beginning of a new sequence\n                        i--;\n                    }\n                    break;\n                case $f0464300f9a0111b$var$S.END:\n                    break;\n                default:\n                    throw new Error(`Unexpected state entered: ${state}`);\n            }\n        }\n        dataCallback(\"onHeaderField\");\n        dataCallback(\"onHeaderValue\");\n        dataCallback(\"onPartData\");\n        // Update properties for the next call\n        this.index = index;\n        this.state = state;\n        this.flags = flags;\n    }\n    end() {\n        if (this.state === $f0464300f9a0111b$var$S.HEADER_FIELD_START && this.index === 0 || this.state === $f0464300f9a0111b$var$S.PART_DATA && this.index === this.boundary.length) this.onPartEnd();\n        else if (this.state !== $f0464300f9a0111b$var$S.END) throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n    }\n}\nfunction $f0464300f9a0111b$var$_fileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n    if (!m) return;\n    const match = m[2] || m[3] || \"\";\n    let filename = match.slice(match.lastIndexOf(\"\\\\\") + 1);\n    filename = filename.replace(/%22/g, '\"');\n    filename = filename.replace(/&#(\\d{4});/g, (m, code)=>{\n        return String.fromCharCode(code);\n    });\n    return filename;\n}\nasync function $f0464300f9a0111b$export$10ae0d317ea97f8b(Body, ct) {\n    if (!/multipart/i.test(ct)) throw new TypeError(\"Failed to fetch\");\n    const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (!m) throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n    const parser = new $f0464300f9a0111b$var$MultipartParser(m[1] || m[2]);\n    let headerField;\n    let headerValue;\n    let entryValue;\n    let entryName;\n    let contentType;\n    let filename;\n    const entryChunks = [];\n    const formData = new (0, $33Q0z.FormData)();\n    const onPartData = (ui8a)=>{\n        entryValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    const appendToFile = (ui8a)=>{\n        entryChunks.push(ui8a);\n    };\n    const appendFileToFormData = ()=>{\n        const file = new (0, $wabHV.File)(entryChunks, filename, {\n            type: contentType\n        });\n        formData.append(entryName, file);\n    };\n    const appendEntryToFormData = ()=>{\n        formData.append(entryName, entryValue);\n    };\n    const decoder = new TextDecoder(\"utf-8\");\n    decoder.decode();\n    parser.onPartBegin = function() {\n        parser.onPartData = onPartData;\n        parser.onPartEnd = appendEntryToFormData;\n        headerField = \"\";\n        headerValue = \"\";\n        entryValue = \"\";\n        entryName = \"\";\n        contentType = \"\";\n        filename = null;\n        entryChunks.length = 0;\n    };\n    parser.onHeaderField = function(ui8a) {\n        headerField += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderValue = function(ui8a) {\n        headerValue += decoder.decode(ui8a, {\n            stream: true\n        });\n    };\n    parser.onHeaderEnd = function() {\n        headerValue += decoder.decode();\n        headerField = headerField.toLowerCase();\n        if (headerField === \"content-disposition\") {\n            // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n            const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n            if (m) entryName = m[2] || m[3] || \"\";\n            filename = $f0464300f9a0111b$var$_fileName(headerValue);\n            if (filename) {\n                parser.onPartData = appendToFile;\n                parser.onPartEnd = appendFileToFormData;\n            }\n        } else if (headerField === \"content-type\") contentType = headerValue;\n        headerValue = \"\";\n        headerField = \"\";\n    };\n    for await (const chunk of Body)parser.write(chunk);\n    parser.end();\n    return formData;\n}\n\n});\n\n\n//# sourceMappingURL=multipart-parser.e63ad71c.js.map\n","import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"names":["parcelRequire","$parcel$global","globalThis","self","window","global","register","module","exports","$wabHV","$33Q0z","$f0464300f9a0111b$export$10ae0d317ea97f8b","Body","ct","headerField","headerValue","entryValue","entryName","contentType","filename","test","TypeError","m","match","parser","$f0464300f9a0111b$var$MultipartParser","entryChunks","formData","FormData","onPartData","ui8a","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","File","type","append","appendEntryToFormData","TextDecoder","chunk","onPartBegin","onPartEnd","length","onHeaderField","onHeaderValue","onHeaderEnd","toLowerCase","$f0464300f9a0111b$var$_fileName","slice","lastIndexOf","replace","code","String","fromCharCode","write","end","Object","defineProperty","get","set","s","enumerable","configurable","$f0464300f9a0111b$var$s","$f0464300f9a0111b$var$S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","$f0464300f9a0111b$var$f","$f0464300f9a0111b$var$F","PART_BOUNDARY","LAST_BOUNDARY","$f0464300f9a0111b$var$lower","c","$f0464300f9a0111b$var$noop","constructor","boundary","index","flags","onHeadersEnd","boundaryChars","Uint8Array","i","charCodeAt","lookbehind","state","data","cl","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","mark","name","clear","callback","callbackSymbol","start","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error"],"version":3,"file":"multipart-parser.e63ad71c.js.map","sourceRoot":"../../"}